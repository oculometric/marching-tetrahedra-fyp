#include <iostream>
#include <string>
#include <format>
#include <fstream>

#include "MTVT.h"
#include "fbm.h"
#include "obj_loader.h"

using namespace std;
using namespace MTVT;

static string memorySize(size_t bytes)
{
    if (bytes >= 2048ull * 1024 * 1024)
        return format("{0:.1f} GiB", (float)bytes / (1024ull * 1024 * 1024));
    else if (bytes >= 2048ull * 1024)
        return format("{0:.1f} MiB", (float)bytes / (1024ull * 1024));
    else if (bytes >= 2048ull)
        return format("{0:.1f} KiB", (float)bytes / 1024);
    else
        return format("{0} B", bytes);
}

void runBenchmark(string name, int iterations, Vector3 min, Vector3 max, float cube_size, float (*sampler)(Vector3), float threshold)
{
    Builder builder;
    try
    {
        builder.configure(min, max, cube_size, sampler, threshold);
        builder.configureModes(Builder::LatticeType::BODY_CENTERED_DIAMOND, Builder::ClusteringMode::NONE, 4);
    }
    catch (exception e)
    {
        cout << "exception during " << name << " benchmark:" << endl;
        cout << e.what() << endl;
        return;
    }
    DebugStats stats;
    Mesh mesh;

    for (int i = 0; i < iterations; ++i)
    {
        cout << format("{0} test iteration {1}/{2}\r", name, i, iterations);
        cout.flush();
        try
        {
            mesh = builder.generate(stats);
        }
        catch (exception e)
        {
            cout << "exception during " << name << " benchmark:" << endl;
            cout << e.what() << endl;
            return;
        }
    }

    float total_time = stats.allocation_time + stats.sampling_time + stats.vertex_time + stats.geometry_time;

    cout << '\b';
    cout <<        "-- summary -----------------------------" << endl;
    cout << format("  {0} test ({1} iterations)", name, iterations) << endl;
    cout << format("  {0}x{1}x{2} resolution", stats.cubes_x, stats.cubes_y, stats.cubes_z) << endl;
    cout <<        "  results:" << endl;
    cout << format("    sample points:  {0} ({1} allocated)", stats.min_sample_points, stats.sample_points_allocated) << endl;
    cout << format("    edges:          {0} ({1} allocated)", stats.min_edges, stats.edges_allocated) << endl;
    cout << format("    tetrahedra:     {0} ({1} evaluated)", stats.max_tetrahedra, stats.tetrahedra_evaluated) << endl;
    cout << format("    vertices:       {0}", stats.vertices) << endl;
    cout << format("    indices:        {0}", stats.indices) << endl;
    cout << format("    degenerates:    {0}", stats.degenerate_triangles) << endl;
    cout << format("  timing:           {0:.6f}s total", total_time / iterations) << endl;
    cout << format("    allocation:     {0:.6f}s ({1:5f}% of total)", stats.allocation_time / iterations, (stats.allocation_time / total_time) * 100.0f) << endl;
    cout << format("    sampling:       {0:.6f}s ({1:5f}% of total)", stats.sampling_time / iterations, (stats.sampling_time / total_time) * 100.0f) << endl;
    cout << format("    vertex:         {0:.6f}s ({1:5f}% of total)", stats.vertex_time / iterations, (stats.vertex_time / total_time) * 100.0f) << endl;
    cout << format("    geometry:       {0:.6f}s ({1:5f}% of total)", stats.geometry_time / iterations, (stats.geometry_time / total_time) * 100.0f) << endl;
    cout <<        "  efficiency (lower number better):" << endl;
    cout << format("    SP allocation:  {0:6f}% ({1})", ((float)stats.sample_points_allocated / stats.min_sample_points) * 100.0f, memorySize(stats.mem_sample_points)) << endl;
    cout << format("    E allocation:   {0:6f}% ({1})", ((float)stats.edges_allocated / stats.min_edges) * 100.0f, memorySize(stats.mem_edges)) << endl;
    cout << format("    T evaluation:   {0:6f}%", ((float)stats.tetrahedra_evaluated / stats.max_tetrahedra) * 100.0f) << endl;
    cout <<        "----------------------------------------" << endl << endl;

    ofstream file(name + ".obj");
    if (!file.is_open())
        return;
    file << "# this file was generated by MTVT" << endl;
    for (Vector3 v : mesh.vertices)
        file << format("v {0:8f} {1:8f} {2:8f}\n", v.x, v.y, v.z);
    if (!mesh.indices.empty())
        for (size_t i = 0; i < mesh.indices.size() - 2; i += 3)
            file << format("f {0} {1} {2}\n", mesh.indices[i] + 1, mesh.indices[i + 1] + 1, mesh.indices[i + 2] + 1);
    file.close();
}

float sphereFunc(Vector3 v)
{
    return mag(v);
}

float fbmFunc(Vector3 v)
{
    return fbm(v * 2.0f, 3, 2.0f, 0.5f);
}

vector<Vector3> bunny_verts;
vector<uint16_t> bunny_inds;
vector<Vector3> bunny_norms;
vector<Vector3> bunny_cents;

float bunnyFunc(Vector3 v)
{
    float min_dist = INFINITY;
    float best_sdf = 0.0f;
    // find closest triangle
    // return closest distance to triangle (signed)
    for (size_t i = 0; i < bunny_cents.size(); ++i)
    {
        Vector3 vc = bunny_cents[i];
        float vcx_dist = vc.x - v.x;
        if (::abs(vcx_dist) > min_dist)
            continue;
        float vcy_dist = vc.y - v.y;
        if (::abs(vcy_dist) > min_dist)
            continue;
        float vcz_dist = vc.z - v.z;
        if (::abs(vcz_dist) > min_dist)
            continue;
        Vector3 c_to_v = { -vcx_dist, -vcy_dist, -vcz_dist };
        if (mag(c_to_v) >= min_dist)
            continue;
        float sdf = c_to_v ^ bunny_norms[i];
        if (::abs(sdf) < min_dist)
        {
            min_dist = mag(c_to_v);
            best_sdf = sdf;
        }
    }
    return -best_sdf;
}

int main()
{
    //runBenchmark("sphere", 1, { -2, -2, -2 }, { 2, 2, 2 }, 0.04f, sphereFunc, 1.0f);
    //runBenchmark("fbm", 1, { -1, -1, -1 }, { 1, 1, 1 }, 0.02f, fbmFunc, 0.0f);
    //runBenchmark("bump", 1, { -4, -4, -4 }, { 4, 4, 4 }, 0.08f, [](Vector3 v) { return (1.0f / ((v.x * v.x) + (v.y * v.y) + 1)) - v.z; }, 0.0f);
    
    readObj("../stanford_bunny/bunny_touchup.obj", bunny_verts, bunny_inds);
    for (size_t i = 0; i < bunny_inds.size() - 2; i += 3)
    {
        Vector3 v1 = bunny_verts[bunny_inds[i]];
        Vector3 v2 = bunny_verts[bunny_inds[i + 1]];
        Vector3 v3 = bunny_verts[bunny_inds[i + 2]];

        Vector3 a = v2 - v1;
        Vector3 b = v3 - v1;
        bunny_norms.push_back(norm(a % b));
        bunny_cents.push_back((v1 + v2 + v3) / 3.0f);
    }

    runBenchmark("bunny", 1, { -0.1f, -0.06f, -0.01f }, { 0.1f, 0.08f, 0.16f }, 0.01f, bunnyFunc, 0.0f);

    return 0;
}
