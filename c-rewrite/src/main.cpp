#include <iostream>
#include <string>
#include <format>
#include <fstream>

#include "MTVT.h"
#include "fbm.h"

using namespace std;

static string memorySize(size_t bytes)
{
    if (bytes >= 2048ull * 1024 * 1024)
        return format("{0:.1f} GiB", (float)bytes / (1024ull * 1024 * 1024));
    else if (bytes >= 2048ull * 1024)
        return format("{0:.1f} MiB", (float)bytes / (1024ull * 1024));
    else if (bytes >= 2048ull)
        return format("{0:.1f} KiB", (float)bytes / 1024);
    else
        return format("{0} B", bytes);
}

void runBenchmark(string name, int iterations, Vector3 min, Vector3 max, float cube_size, float (*sampler)(Vector3), float threshold)
{
    MTVTBuilder builder;
    builder.configure(min, max, cube_size, sampler, threshold);
    MTVTDebugStats stats;
    MTVTMesh mesh;

    for (int i = 0; i < iterations; ++i)
    {
        cout << format("{0} test iteration {1}/{2}\r", name, i, iterations);
        cout.flush();
        mesh = builder.generate(stats);
    }

    float total_time = stats.allocation_time + stats.sampling_time + stats.vertex_time + stats.geometry_time;

    cout << '\b';
    cout <<        "-- summary -----------------------------" << endl;
    cout << format("  {0} test ({1} iterations)", name, iterations) << endl;
    cout << format("  {0}x{1}x{2} resolution", stats.cubes_x, stats.cubes_y, stats.cubes_z) << endl;
    cout <<        "  results:" << endl;
    cout << format("    sample points:  {0} ({1} allocated)", stats.min_sample_points, stats.sample_points_allocated) << endl;
    cout << format("    edges:          {0} ({1} allocated)", stats.min_edges, stats.edges_allocated) << endl;
    cout << format("    tetrahedra:     {0} ({1} evaluated)", stats.max_tetrahedra, stats.tetrahedra_evaluated) << endl;
    cout << format("    vertices:       {0}", stats.vertices) << endl;
    cout << format("    indices:        {0}", stats.indices) << endl;
    cout << format("    degenerates:    {0}", stats.degenerate_triangles) << endl;
    cout << format("  timing:           {0:.6f}s total", total_time / iterations) << endl;
    cout << format("    allocation:     {0:.6f}s ({1:5f}% of total)", stats.allocation_time / iterations, (stats.allocation_time / total_time) * 100.0f) << endl;
    cout << format("    sampling:       {0:.6f}s ({1:5f}% of total)", stats.sampling_time / iterations, (stats.sampling_time / total_time) * 100.0f) << endl;
    cout << format("    vertex:         {0:.6f}s ({1:5f}% of total)", stats.vertex_time / iterations, (stats.vertex_time / total_time) * 100.0f) << endl;
    cout << format("    geometry:       {0:.6f}s ({1:5f}% of total)", stats.geometry_time / iterations, (stats.geometry_time / total_time) * 100.0f) << endl;
    cout <<        "  efficiency (lower number better):" << endl;
    cout << format("    SP allocation:  {0:6f}% ({1})", ((float)stats.sample_points_allocated / stats.min_sample_points) * 100.0f, memorySize(stats.mem_sample_points)) << endl;
    cout << format("    E allocation:   {0:6f}% ({1})", ((float)stats.edges_allocated / stats.min_edges) * 100.0f, memorySize(stats.mem_edges)) << endl;
    cout << format("    T evaluation:   {0:6f}%", ((float)stats.tetrahedra_evaluated / stats.max_tetrahedra) * 100.0f) << endl;
    cout <<        "----------------------------------------" << endl << endl;

    ofstream file(name + ".obj");
    if (!file.is_open())
        return;
    file << "# this file was generated by MTVT" << endl;
    for (Vector3 v : mesh.vertices)
        file << format("v {0:8f} {1:8f} {2:8f}\n", v.x, v.y, v.z);
    
    for (size_t i = 0; i < mesh.indices.size() - 2; i += 3)
        file << format("f {0} {1} {2}\n", mesh.indices[i] + 1, mesh.indices[i + 1] + 1, mesh.indices[i + 2] + 1);
    file.close();
}


float sphereFunc(Vector3 v)
{
    return mag(v);
}

float fbmFunc(Vector3 v)
{
    return fbm_noise({ v.x / 4.0f, v.y / 4.0f, 0.0f });
}

int main()
{
    runBenchmark("sphere", 100, { -2, -2, -2 }, { 2, 2, 2 }, 0.04f, sphereFunc, 1.0f);
    // FIXME: fbm benchmark completely broken, possibly due to geometry on the edges of the sample volume (need to introduce handling and add back in the -1 checks for debugging, also are we going out of bounds??)
    //runBenchmark("fbm", 2, { -1, -1, -1 }, { 1, 1, 1 }, 0.05f, fbmFunc, 0.0f);
    //runBenchmark("divider", 10, { -5, -5, -5 }, { 5, 5, 5 }, 1.0f, [](Vector3 v) { return v.x * v.y; }, 1.0f);
}
