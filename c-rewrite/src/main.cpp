#include <iostream>
#include <string>
#include <format>
#include <fstream>

#include "MTVT.h"

using namespace std;

void runBenchmark(string name, int iterations, Vector3 min, Vector3 max, float cube_size, float (*sampler)(Vector3), float threshold)
{
    MTVTBuilder builder;
    builder.configure(min, max, cube_size, sampler, threshold);
    MTVTDebugStats stats;
    MTVTMesh mesh;

    for (int i = 0; i < iterations; ++i)
    {
        cout << format("{0} test iteration {1}/{2}\r", name, i, iterations);
        cout.flush();
        mesh = builder.generate(stats);
    }

    cout << '\b';
    cout <<        "-- summary -----------------------------" << endl;
    cout << format("  {0} test ({1} iterations)", name, iterations) << endl;
    cout << format("  {0}x{1}x{2} resolution", stats.cubes_x, stats.cubes_y, stats.cubes_z) << endl;
    cout <<        "  results:" << endl;
    cout << format("    sample points:  {0} ({1} allocated)", stats.min_sample_points, stats.sample_points_allocated) << endl;
    cout << format("    edges:          {0} ({1} allocated)", stats.min_edges, stats.edges_allocated) << endl;
    cout << format("    tetrahedra:     {0}", stats.tetrahedra) << endl;
    cout << format("    vertices:       {0}", stats.vertices) << endl;
    cout << format("    indices:        {0}", stats.indices) << endl;
    cout <<        "  performance:" << endl;
    cout << format("    allocation:     {0:.6f}s", stats.allocation_time / iterations) << endl;
    cout << format("    sampling:       {0:.6f}s", stats.sampling_time / iterations) << endl;
    cout << format("    vertex:         {0:.6f}s", stats.vertex_time / iterations) << endl;
    cout << format("    geometry:       {0:.6f}s", stats.geometry_time / iterations) << endl;
    cout <<        "----------------------------------------" << endl << endl;

    ofstream file(name + ".obj");
    if (!file.is_open())
        return;
    file << "# this file was generated by MTVT" << endl;
    for (Vector3 v : mesh.vertices)
        file << format("v {0:8f} {1:8f} {2:8f}\n", v.x, v.y, v.z);
    file.close();
}

float sphereFunc(Vector3 v)
{
    return mag(v - Vector3{ 4, 4, 4 }) / 4.0f;
}

int main()
{
    runBenchmark("sphere", 100, { 0, 0, 0 }, { 8, 8, 8 }, 0.08f, sphereFunc, 1.0f);
}
